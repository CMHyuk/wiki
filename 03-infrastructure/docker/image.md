### 이미지
도커 목적 = 가상화 서버를 빠르고 가볍게 운영하기 위해 사용

이미지 = 특정 서버를 실행할 수 있는 저장한 압축 파일  
* os, 의존 요소, 소프트웨어가 포함되어 있는 압축파일  
* 호스트 OS안에서 격리된 컨테이너가 만들어지고 실행됨

### 이미지와 컨테이너
#### 프로그램  
* 실행 가능한 소프트웨어
* 디스크 공간 차지 

#### 프로세스  
* 실행 상태의 소프트웨어  
* 프로그램 1 : N 프로세스  
* 실행 시 CPU, MEM 등의 리소스 사용  

#### 이미지  
* 실행 가능한 소프트웨어 + 실행에 필요한 환경  
* 디스크 공간 차지

#### 컨테이너  
* 실행 상태의 이미지
* 이미지 1 : N 컨테이너  
* 컨테이너로 실행 시  CPU, MEM 등의 리소스 사용  
* 컨테이너 간 리소스 격리  
* 실행 시 이미지를 복사해 격리된 디스크 공간 생성  
* 컨테이너 실행 시 프로세스도 함께 실행

`docker image ls (이미지명)` - 로컬 이미지 조회  

`docker run -d --name {컨테이너 명} 이미지명`  
* -d : 백그라운드 실행 
* --name {컨테이너 명} : 컨테이너 이름 지정

`docker ps` - 실행 중인 컨테이너 리스트 조회

`docker rm -f` - 실행 중인 컨테이너 삭제

### 이미지와 메타데이터
ENV = 소프트웨어가 실행 시 참조할 설정 정보

CMD = 컨테이너 실행 시 프로세스 실행 명령어 지정

`docker image inspect 이미지명` - 이미지의 세부 정보 조회

`docker container inspect 컨테이너명` - 컨테이너의 세부 정보 조회

`docker run 이미지명 (실행명령)` - 컨테이너 실행 시 메타데이터의 cmd 덮어쓰기

`docker run --env KEY=VALUE 이미지명` - 컨테이너 실행 시 메타데이터의 env 덮어쓰기

`docker ps -a` - 종료된 컨테이너 포함 모든 컨테이너 조회

### 이미지 레지스트리
#### 이미지 레지스트리

* 이미지를 저장하는 저장소

* 이미지 공유, 검색, 버전 관리, 보안, 파이프라인

#### 저장 공간

* 퍼블릭 레지스트리

* 프라이빗 레즈스트리

* 호스트 머신의 로컬 스토리지

#### 동작 과정

1. docker run nginx

2. 로컬 스토리지의 이미지 검색

3. (스토리지에 이미지가 없으면) 레지스트리의 이미지 다운로드

#### 이미지 명 규칙   
* 레지스트리주소/프로젝트명/이미지명:이미지태그  
```docker run -d -p 80:80 --name hellonginx nginx```

## 이미지 레이어

이미지는 레이어드 파일 시스템으로 구성되어 있음  
- 재사용하기 유리  
- 효율적인 데이터 저장과 전송

이미지의 레이어는 이전 레이어의 변경 사항이 저장  
컨테이너 실행 시 읽기, 쓰기 가능한 새로운 레이어 추가

컨테이너 레이어 - 읽기/쓰기 레이어  
이미지 레이어 - 읽기 전용 레이어

```docker image history 이미지명``` - 이미지의 레이어 이력 조회

레이어 방식은 중복 데이터를 최소화하고, 빌드 속도를 높이며, 저장소를 효율적으로 사용할 수 있게 해준다.

## 이미지 커밋

#### 이미지 커밋  
커밋: 현재 컨테이너의 상태를 이미지로 저장  
빌드: Dockerfile을 통해 이미지를 저장  

`docker run -it --name 컨테이너명 이미지명 bin/bash`  - 컨테이너 실행과 동시에 터미널 접속

`docker commit -m 커밋명 실행중인컨테이너명 생성할이미지명`  - 실행 중인 컨테이너를 이미지로 생성

#### 동작 방식  
1. Nginx 이미지를 컨테이너를 실행
2. 컨테이너의 내부 파일 변경
3. Commit으로 새로운 이미지로 저장

## 이미지 빌드
#### 인프라 관리 방식
* 기존 방식
사람이 화면이나 CLI를 통해 관리  
보통 대시보드에서 클릭, 명령을 실행함 -> 인수인계 상황에서 작업과정을 가이드를 만들어야 함 -> 휴먼 에러 발생 가능성



* Iac(Infrastructure as Code): 인프라 상태를 코드로 관리
  * 프로그램이 코드를 읽어 인프라 관리 
  * 사람은 원하는 상태를 코드로 작성


* Dockerfile: 이미지를 만드 단계를 기재한 명세서
  * 원하는 이미지 상태를 코드로 작성 docker build 명령을 통해 이미지 생성
    1. 임시 컨테이너 생성
    2. 변경사항 적용 후 커밋 (새로운 레이어 생성)
    3. 임시 컨테이너 삭제

```
FROM 이미지명 - 베이스 이미지를 지정
COPY 파일경로 복사할 경로 - 파일을 레이어에 복사
CMD ["명령어"] - 컨테이너 실행 시 명령어 지정
```


## 빌드 컨텍스트
#### 빌드 컨텍스트  
* 이미지를 빌드할 때 전달되는 폴더 (도커 파일, 카피에 사용될 파일)
* .dockerignore의 파일 리스트는 빌드 컨텍스트에 전달하지 않음

#### 동작 순서
1. 빌드 명령 시 도커 데몬에 지정한 폴더 전달 
   * 전달해주는 폴더가 빌드 컨텍스트
2. 빌드 컨텍스트의 Dockerfile로 빌드 시작, FROM의 베이스 이미지로 임시 컨테이너 생성 
3. 베이스 이미지로 실행한 임시 컨테이너 
4. COPY 
   * COPY 지시어로 빌드에 사용되는 컨테이너로 복사


## 도커 지시어
```
FROM 이미지명 - 베이스 이미지를 지정

COPY 빌드컨텍스트경로 레이어 경로 - 빌드 컨텍스트의 파일을 레이어에 복사

RUN 명령어 - 명령어 실행

CMD ["명령어"] - 컨테이너 실행 시 명령어 지정

docker build -f 도커파일명 -t 이미지명 Dockerfile 경로

WORKDIR 폴더명 - 작업 디렉토리를 지정

USER 유저명 - 명령을 실행할 사용자 변경

EXPOSE 포트번호 - 컨테이너가 사용할 포트를 명시

ARG 변수명 변수값 - 이미지 빌드 시점의 환경 변수 설정

ENV 변수명 변수값 - 이미지 빌드 및 컨테이너 실행 시점의 환경 변수 설정

ENTRYPOINT ["명령어"] - 고정된 명령어를 지정

CMD ["명령어"] - 컨테이너 실행 시 실행 명령어 지정
```

## 멀티 스테이지 빌드
* 도커 파일에서 두 개의 베이스 이미지를 활용하는 방법 
* 실행 스테이지, 빌드 스테이지로 나눈 방식 
  * 단일 스테이지 빌드 방식은 실행에 불필요한 소스코드, 라이브러리, 실행파일 등 포함
* 실행, 빌드 스테이지로 나누어 이미지 크기를 줄여 속도 다운로드, 실행 속도 향상 
* FROM이 두 개 있으면 도커는 컨테이너를 동시에 생성하고 첫 번째 컨테이너 생성된 파일을 두 번째 컨테이너로 복사

## **어떻게 싱글톤을 보장?**

1. CGLIB 바이트코드 조작 라이브러리를 사용해서 해당 클래스를 상속받은 임의의 다른 클래스를 만듦 
2. 다른 클래스를 스프링 빈으로 등록 -> 싱글톤 보장
* 참고 
  * @Configuration 사용 안 하면 스프링 빈으로 등록은 되지만 싱글톤 x

## 의존관계 주입
* 수정자 주입
  * 선택, 변경 가능성이 있을 때 사용 자바빈 프로퍼티 규약을 이용해 의존관계 누락되어도 컴파일 오류 발생 x

* 필드 주입  
  * 일반적인 POJO(자바 객체)로 사용했을 때도 의존성을 주입해줄 방법이 있다. 그러나 필드 주입은 스프링 컨테이너 없이 의존 객체를 주입해줄 방법이 없다.

* 생성자 주입
  * final 키워드를 사용하기 때문에 의존관계 누락시 컴파일 단계에서 오류를 잡아냄

## 스프링 MVC 구조
1. **핸들러 조회**: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. **핸들러 어댑터 조회**: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. **핸들러 어댑터 실행**: 핸들러 어댑터를 실행한다.

4. **핸들러 실행**: 핸들러 어댑터가 실제 핸들러를 실행한다.
5. **ModelAndView 반환**: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
6. **viewResolver 호출**: 뷰 리졸버를 찾고 실행한다.  
   * JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.
   * JSON의 경우 : viewResolver가 아닌 **MappingJackson2HttpMessageConverter** 동작
7. **View반환** : 뷰리졸버는 뷰의 논리이름을 물리이름으로 바꾸고,렌더링 역할을 담당하는 뷰객체를 반환한다.
   * JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.
8. **뷰렌더링** : 뷰를 통해서 뷰를 렌더링한다.

## 스프링 빈 생명주기

* 스프링 컨테이너 생성 → 스프링 빈 생성 → 의존 관계 주입 → 초기화 콜백 → 사용 → 소멸 전 콜백 → 종료
  * 수정자 및 필드 주입은 "의존관계 주입" 단계에서 이루어진다. 스프링이 빈을 먼저 생성한 후, Setter 또는 필드를 주입하기 때문이다.
  * 생성자 주입은 "스프링 빈 생성" 단계에서 이루어진다. 스프링이 빈을 생성할 때, 생성자를 호출하면서 의존성을 주입해야 한다. 즉, 객체를 생성할 때 생성자의 매개변수로 의존성이 전달되므로, 의존성 주입은 "스프링 빈 생성" 단계에서 수행된다.

## MessageConverter

* 스프링 메시지 컨버터는 HTTP 요청 또는 응답의 바디를 객체로 변환하거나 객체를 HTTP 요청 또는 응답의 바디로 변환하는 기능을 수행  

#### 요청 데이터  
핸들러 어댑터가 ```ReqeustMappingHandlerAdapter```이면 ```ArgumentResolver```를 호출 하는데 ```@Requestparam``` ```@ModelAtttibrute```등 여러 가지 애노테이션을 처리
이때 ```@ReuqestBody```와 같이 Http 메시지를 처리하는 애노테이션의 경우 ```HttpMessageConverter```가 동작한다.
내부적으로 http 요청 데이터를 읽기 위해 ```canRead()```메서드가 실행되는데, 대상 클래스 타입을 지원하는지? Content-Type 미디어 타입을 지원하는지? 확인 후 조건 만족 시 ```read()```를 호출해 객체를 생성 후 반환한다.

#### 응답 데이터  
```ArgumentResolver```가 아닌 ```ReturnValueHandler```가 ```HttpMessageConverter```를 호출해 canWrite()가 호출되어 요청 데이터와 마찬가지로 클래스 타입, 미디어 타입을 지원하는지 확인 후 조건 만족 시 write() 메서드를 호출해 http 응답 메시지 바디에 데이터를 생성한다.

## 논리 트랜잭션과 물리 트랜잭션
* 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶임
* 물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻함
* 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위

#### 원칙
* 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋
* 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백
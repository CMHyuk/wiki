### 쓰레드 로컬
* 쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소  

**ThreadLocal 사용법**  
값 저장: `ThreadLocal.set(xxx)`  
값 조회: `ThreadLocal.get()`  
값 제거: `ThreadLocal.remove()`

**쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생**

* 저장 요청
1. 사용자A가 저장 HTTP를 요청했다.
2. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
3. 쓰레드 `thread-A` 가 할당되었다.
4. `thread-A` 는 `사용자A` 의 데이터를 쓰레드 로컬에 저장한다.
5. 쓰레드 로컬의 `thread-A` 전용 보관소에 `사용자A` 데이터를 보관한다.

* 저장 요청 종료
1. 사용자A의 HTTP 응답이 끝난다.
2. WAS는 사용이 끝난 `thread-A` 를 쓰레드 풀에 반환한다. 쓰레드를 생성하는 비용은 비싸기 때문에 쓰레드를 제거하지 않고, 보통 쓰레드 풀을 통해서 쓰레드를 재사용한다.
3. `thread-A` 는 쓰레드풀에 아직 살아있다. 따라서 쓰레드 로컬의 `thread-A` 전용 보관소에 `사용자A` 데이터도 함께 살아있게 된다.

-> 다른 사용자가 사용자 A의 데이터를 확인하게 되는 문제가 발생함

### 템플릿 메서드 패턴

- 장점
    - 핵심 기능과 부가기능을 나눌 수 있음
- 단점
    - 기존 로직을 건드려야함

### 프록시 패턴 vs 데코레이터 패턴

프록시 패턴 : 접근 제어가 목적  
데코레이터 패턴 : 새로운 기능 추가가 목적

### 프록시 패턴

- 장점
    - 기존 로직을 건들지 않아도 됨
- 단점
    - 적용 대상이 100개면 프록시 클래스도 100개 만들어야 함

### 인터페이스 기반 프록시 vs 클래스 기반 프록시

- 인터페이스가 없어도 클래스 기반으로 프록시를 생성 가능
- 클래스 기반 프록시는 해당 클래스에만 적용 가능, 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용 가능

### 클래스 기반 프록시 제약

- 부모 클래스의 생성자를 호출해야함
- 클래스에 final 키워드가 붙으면 상속이 불가능
- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 x

### 리플렉션 사용하지 말자

애플리케이션을 동적으로 만들 수 있지만 컴파일 단계에서 오류를 잡아내지 못함

`getMethod("callA")` 을 실수로 `getMethod("callZ")` 로 해도 컴파일 오류 x

프로그래밍 언어가 발달하면서 타입 정보를 기반으로 컴파일 시점에 오류를 잡아준 덕분에 편했는데, 리플렉션은 그것을 역행하는 방식

JDK 동적 프록시는 인터페이를 구현 (implements) CGLIB은 구체 클래스를 상속(extends)

### CGLIB 제약

클래스 기반 프록시는 상속을 사용

- 부모 클래스의 생성자를 체크 -> CGLIB은 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요
- 클래스에 `final`키워드가 붙으면 상속 불가능 -> CGLIB에선 예외가 발생
- 메서드에 `final` 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없음 -> CGLIB에서는 프록시 로직이 동작 x

### 프록시 팩토리
- 인터페이스가 있는 경우에 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에 CGLIB을 적용하려면?
  - 프록시 팩토리를 이용해 둘 대신에 `Adivce` 를 사용하면 됨

```java
Target target = new Target();
ProxyFactory proxyFactory = new ProxyFactory(tartget);
proxyFactory.addAdvice(new TimeAdvice());
proxyFactory.getProxy();
// proxyFactory.setProxyTargetClass(true) 인터페이스가 있어도 무조건 CGLIB
```

**포인트컷**( `Pointcut` )
* 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직, 주로 클래스와 메서드 이름으로 필터링 이름 그대로 어떤 포인트(Point)에 기능을 적용할지 하지 않을지 잘라서(cut) 구분

**어드바이스**( `Advice` )  
* 이전에 본 것 처럼 프록시가 호출하는 부가 기능, 단순하게 프록시 로직이라 생각하면 됨

**어드바이저**( `Advisor` )  
* 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것, 쉽게 이야기해서 **포인트컷1 + 어드바이스1**
* 정리하면 부가 기능 로직을 적용해야 하는데, 포인트컷으로 어디에? 적용할지 선택하고, 어드바이스로 어떤 로직을 적용할지 선택하는 것, 그리고 어디에? 어떤 로직?을 모두 알고 있는 것이 **어드바이저**

**AOP 적용 수 만큼 프록시가 생성된다고 착각하지만 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용함**

### 빈 후처리기
스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용하면 됨

**빈 등록 과정**  
**1. 생성:** 스프링 빈 대상이 되는 객체를 생성한다. ( `@Bean` , 컴포넌트 스캔 모두 포함)  
**2. 전달:** 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.  
**3. 후 처리 작업:** 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바뀌치기 할 수 있다.  
**4. 등록:** 빈 후처리기는 빈을 반환한다. 전달 된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면 다른 객 체가 빈 저장소에 등록된다.

### 자동 프록시 생성기의 작동 과정  
**1. 생성:** 스프링 빈 대상이 되는 객체를 생성한다. ( `@Bean` , 컴포넌트 스캔 모두 포함)  
**2. 전달:** 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.  
**3-1. Advisor 빈 조회:** 스프링 컨테이너에서 `Advisor` 빈을 모두 조회한다.  
**3-2. @Aspect Advisor 조회:** `@Aspect` 어드바이저 빌더 내부에 저장된 `Advisor` 를 모두 조회한다.  
**4. 프록시 적용 대상 체크:** 앞서 3-1, 3-2에서 조회한 `Advisor` 에 포함되어 있는 포인트컷을 사용해서 해당 객 체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드 를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다. 예를 들어 서 메서드 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.  
**5. 프록시 생성:** 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환한다. 그래서 프록시를 스프링 빈으로 등 록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.  
**6. 빈 등록:** 반환된 객체는 스프링 빈으로 등록된다.

### 포인트컷 지시자
**포인트컷 지시자의 종류**

`execution` : 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡하다.  
`within` : 특정 타입 내의 조인 포인트를 매칭한다.  
`args` : 인자가 주어진 타입의 인스턴스인 조인 포인트  
`this` : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트  
`target` : Target 객체(스프링 AOP 프록시가 가리키는 실제 대상)를 대상으로 하는 조인 포인트  
`@target` : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트  
`@within` : 주어진 애노테이션이 있는 타입 내 조인 포인트  
`@annotation` : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭  
`@args` : 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트  
`bean` : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다.

### args, @args, @target 주의점
"실행 시점에 일어나는 포인트컷 적용 여부도 결국 프록시가 있어야 실행 시점에 판단할 수 있다."에서 말하는 '실행'은**프록시로 생성된 인스턴스의 메소드 실행을 의미** 즉, 애플리케이션의 전체 실행이 아니라,**AOP가 적용된 메소드가 호출될 때**를 말한다. **프록시는 이 메소드 호출이 포인트컷에 정의된 패턴과 일치하는지를 실행 시점에 검사하여, 조건에 맞는 경우에만 어드바이스(Advice)를 적용**한다.

`@target`지시자는 특정 어노테이션이 붙은 대상 객체에만 AOP를 적용하도록 한다. 하지만 중요한 점은 스프링이 이런 포인트컷을 사용할 때, 실제 인스턴스가 생성되어 해당 어노테이션이 적용되었는지 확인하기 전에는 정확하게 AOP 적용 여부를 결정할 수 없다는 것이다. 따라서 스프링은 포인트컷 조건을 충족할 가능성이 있는 모든 빈에 대해 프록시를 생성하고, 실제 메소드 실행 시에 포인트컷 조건이 맞는지를 검사하게 된다. 문제는 이렇게 모든 스프링 빈에 AOP 프록시를 적용하려고 하면 스프링이 내부에서 사용하는 빈 중에는 `final` 로 지정된 빈들도 있기 때문에 오류가 발생할 수 있다.

**프록시 적용 조건의 복잡성**:`@target`이 참조하는 애너테이션이 인스턴스에 존재하는지 여부는 객체가 실제로 생성된 후에만 확인할 수 있다. 예를 들어, 런타임에 빈의 정의에 따라 다른 애너테이션을 부여하거나, 빈 포스트 프로세서를 통해 애너테이션을 동적으로 추가하는 경우가 있을 수 있다.

### 왜 final 클래스에 프록시를 적용할 수 없을까?
final 클래스는 상속을 금지하는 클래스이다. 이는 해당 클래스의 기능을 변경하거나 확장하지 못하도록 하기 위한 것인데, CGLIB가 프록시를 만들 때, 프록시 클래스는 원본 클래스를 상속하여 동작을 변경한다. 그러나 final 클래스는 상속이 금지되어 있으므로, CGLIB는 final 클래스를 상속한 프록시 클래스를 만들 수 없어서 오류가 발생하게 된다.

### 실무 주의사항
프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.
* 해결 방안 1
  * 자기 자신을 의존관계 주입 생성자 주입은 순환 사이클을 만들기 때문에 실패 -> 수정자 주입으로 해결
* 해결 방안 2
  * `ObjectProvider`를 이용해 객체를 스프링 컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아니라 실제 객체를 사용하는 시점으로 지연 조회
* 해결 방안 3
  * 내부 호출하지 않도록 별도의 클래스로 분리

### 프록시 기술과 한계
**JDK 동적 프록시 한계**
* 인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능한 한계가 있다.

**CGLIB 구체 클래스 기반 프록시 문제점** 
* 대상 클래스에 기본 생성자 필수 
* 생성자 2번 호출 문제
* final 키워드 클래스, 메서드 사용 불가

### 스프링의 해결책
**CGLIB 기본 생성자 필수 문제 해결**  
스프링 4.0부터 CGLIB의 기본 생성자가 필수인 문제가 해결되었다.
`objenesis` 라는 특별한 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다. 참고로 이 라이브러리는 생성자 호출 없이 객체를 생성할 수 있게 해준다.

**생성자 2번 호출 문제**  
스프링 4.0부터 CGLIB의 생성자 2번 호출 문제가 해결되었다. 이것도 역시 `objenesis` 라는 특별한 라이브러리 덕분에 가능해졌다. 이제 생성자가 1번만 호출된다.

CGLIB의 남은 문제라면 `final` 클래스나 `final` 메서드가 있는데, AOP를 적용할 대상에는 `final` 클래스나
`final` 메서드를 잘 사용하지는 않으므로 이 부분은 크게 문제가 되지는 않는다.

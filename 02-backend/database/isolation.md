**Dirty read**

- commit 되지 않은 변화를 읽음

**Non-repeatable read = Fuzzy read**

- 같은 데이터의 값이 달라짐

**Phantom read**

- 없던 데이터가 생김
  - 한 트랜잭션 내에서 동일한 쿼리 2번 이상 보냈을 때 해당 조회 결과가 다름 (새로운 행이 추가 + 삭제 가능)

이런 이상 현상들이 모두 발생하지 않게 만들 수 있지만 제약사항이 많아져서 동시 처리 가능한 트랜잭션 수가 줄어들어 결국 DB의 처리량이 줄어듦

→ Isolation level을 통해 전체 처리량과 일관성 사이에서 어느 정도 거래할 수 있음

| Isolation level | Dirty read | Non-repeatable read | Phantom read |
| --- | --- | --- | --- |
| Read uncommitted | o | o | o |
| Read committed | x | o | o |
| Repeatable read | x | x | o |
| Serializable | x | x | x |

**SERALIZAlBLE**
- 커밋 완료된 데이터 대해서만 조회할 수 있으며 트랜잭션을 순차적으로 진행시키는 것. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음

**REPEATABLE_READ**
- 커밋 완료된 데이터 대해서만 조회할 수 있으며 반복 조회해도 같은 행을 보장 새로운 행을 추가하는 건 막지 않음
- 자신보다 늦게 시작한 트랜잭션이 있으면 데이터 변경이 있어도 언두 로그로 조회해서 같은 행 보장
- MySQL 기본 값 (MySQL에선 팬텀 리드가 거의 일어나지 않음)

예시
1. **트랜잭션 1:**
  - 데이터 A를 읽습니다.
  - 데이터 A를 변경하고 커밋합니다.
2. **트랜잭션 2 (`REPEATABLE_READ` 격리 수준):**
  - 동일한 데이터 A를 읽습니다.
  - 트랜잭션 1이 커밋했지만, 트랜잭션 2에서는 처음에 읽은 시점의 데이터 A를 읽습니다.
  - 트랜잭션 1이 변경한 내용이 트랜잭션 2에 반영되지 않습니다.
3. **트랜잭션 1:**
  - 데이터 A를 다시 변경하고 커밋합니다.
4. **트랜잭션 2:**
  - 동일한 데이터 A를 다시 읽습니다.
  - 이때 데이터 A는 트랜잭션 1에 의해 변경되었지만, **`REPEATABLE_READ`** 격리 수준에서는 처음에 읽은 시점의 데이터를 유지합니다. 따라서 처음에 읽은 것과 다른 값을 얻지 않습니다.

**READ_COMMITED**
- 커밋 완료된 데이터에 대해서만 조회할 수 있으며 커밋이 되지 않은 정보는 읽지 못함

예시
1. **트랜잭션 1:**
  - 데이터 A를 읽습니다.
  - 데이터 A를 변경하고 커밋합니다.
2. **트랜잭션 2 (`READ_COMMITTED` 격리 수준):**
  - 동일한 데이터 A를 읽습니다.
  - 트랜잭션 1이 커밋했기 때문에 트랜잭션 2는 커밋된 데이터를 읽습니다.
3. **트랜잭션 1:**
  - 데이터 A를 다시 변경하고 커밋합니다.
4. **트랜잭션 2:**
  - 동일한 데이터 A를 다시 읽습니다.
  - 이때 데이터 A는 트랜잭션 1에 의해 변경되었기 때문에 처음에 읽은 것과 다른 값을 얻게 됩니다.

**READ_UNCOMMITED**
- 가장 낮은 격리 수준이며 가장 빠름, 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수 있음

예시
1. **트랜잭션 1:**
  - 데이터 A를 읽습니다.
2. **트랜잭션 2 (`READ_UNCOMMITTED` 격리 수준):**
  - 동일한 데이터 A를 변경하고 아직 커밋하지 않습니다.
3. **트랜잭션 1:**
  - 데이터 A를 변경된 것으로 읽습니다. 이때 트랜잭션 2의 변경 내용을 읽어옴.
4. **트랜잭션 2:**
  - 데이터 A를 커밋합니다.

**Dirty write**

- commit 안된 데이터를 write
    - rollback 시 정상적은 recovery는 매우 중요하기 때문에 모든 isolation level에서 dirty write를 허용하면 안됨

**Lost update**

- 업데이트를 덮어씀

**SNAPSHOT ISOLATION**
- 동시성을 어떻게 컨트롤할지에 대한 내용
- tx 시작 전에 commit된 데이터만 보임
- First-committer win (같은 데이터에 대해 write complete가 발생하면 첫 번째만 반영)
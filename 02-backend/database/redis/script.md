### Redis Script
* Save와 Delete 연산을 순차적으로 수행해야 하는 상황에서 Save Delete 사이에 다른 연산이 일어나면 Atomic이 보장 x
  * 이를 해결하기 위해 **파이프 라인, 트랜잭션, 스크립트**를 사용할 수 있다.
  
**파이프 라인**
* 파이프라인 기능은 명령을 한 번에 모아서 보내 네트워크 I/O를 줄이기 위한 기법이기 때문에 원자성을 위해 사용되지는 않는다.

**트랜잭션**
* Redis 클러스터 환경에서는 관리가 어렵다
  * 데이터가 여러 노드에 샤딩되어 저장되기 때문에, 어떤 키가 어느 노드에 있는지 클라이언트가 모두 알 수 없다.
  * 리샤딩(데이터 재분배)이 발생할 가능성도 존재해, 특정 노드에 키가 지속적으로 위치할 거라고 보장할 수 없다.

**Lua Script**
* Lua 스크립트는 단일 명령으로 취급되며, 실행 도중 다른 명령이 개입할 수 없다.
  * 이를 통해 트랜잭션과 같은 기능을 제공하여 여러 명령을 조합한 연산을 원자적으로 처리할 수 있다.
* 클라이언트와 Redis 서버 간에 주고받아야 할 명령어를 줄여주어 네트워크 왕복 횟수를 줄이고, 성능을 향상시킨다. 
  * 예를 들어, 복잡한 계산이나 반복적인 명령을 클라이언트에서 반복 실행하는 대신, 한 번의 Lua 스크립트로 서버에서 수행할 수 있다.
* 스크립트는 Redis 서버에 해시 값으로 저장된다. 
  * 동일한 스크립트를 반복해서 사용할 경우 Redis는 해당 스크립트를 캐싱하여 재사용이 가능하도록 하여 성능을 높인다.

**EVAL**
* Redis에서 Lua 스크립트를 실행하는 기본 명령어이다. 
  * `EVAL "return redis.call('set', KEYS[1], ARGV[1])" 1 key1 value1`
  * KEYS와 ARGV는 각각 Redis 키와 스크립트 인자로, 이를 통해 다양한 값과 키를 전달할 수 있다.

### Cluster과 효율적인 키 관리 기법
* 메모리 부족 문제
  * Redis는 인메모리(in-memory) 데이터 저장소이기 때문에 저장 가능한 데이터 크기는 서버의 물리적 메모리 용량에 제한된다.

**샤딩(Sharding) 기법**
* 샤딩은 데이터를 여러 개의 데이터베이스 노드에 분산 저장하는 기법이다. 
* 하나의 Redis 노드가 모든 데이터를 저장하지 않도록 하고, 데이터를 분산함으로써 메모리 부족 문제를 완화한다. 
* Redis 클러스터에서는 자동으로 샤딩을 지원하여, 사용자가 별도로 데이터를 분할하는 작업을 하지 않아도 된다.

**Redis의 키와 샤딩 위치 결정**
* Redis 클러스터에서 각 키는 특정 노드에 저장된다. 
* 키가 저장될 노드를 결정하기 위해 Redis는 각 키를 해싱 처리한 후 샤드 개수로 나눈다. 
* 해싱된 값이 특정 노드(샤드)에 해당하는지 여부를 계산하여, 키가 어느 샤드에 저장될지 결정한다.

**샤드 노드와 키 재정립 문제**
* 클러스터 확장 시, 새로운 샤드를 추가하면 기존의 해시 방식에서는 모든 키의 저장 위치를 재정립해야 하는 문제가 생긴다. 
* 재정립 작업은 많은 리소스를 소모하며, 모든 키의 재분배가 필요한 경우 시스템에 큰 부하를 줄 수 있다.

**해시 슬롯 (Hash Slot)**
* Redis 클러스터는 이 문제를 해결하기 위해 해시 슬롯(hash slots) 개념을 도입했다. 
* 16,384개의 슬롯이 미리 설정되어 있고, 각 키는 해시 함수로 계산된 슬롯 번호를 통해 특정 슬롯에 매핑된다. 
* 각 노드는 이러한 해시 슬롯을 여러 개 할당받아 관리하므로, 샤드를 추가하거나 제거할 때 모든 키의 재분배가 필요하지 않고, 슬롯의 재분배만 수행한다.

**해시 슬롯의 관리 방식**
* Redis 클러스터는 키와 해시 슬롯을 맵(Map) 형태로 관리하여, 각 노드가 특정 슬롯에 해당하는 키를 처리할 수 있도록 한다.

**샤드 노드와 키 재정립 예시**
* Redis 클러스터가 2개의 샤드 노드(A, B)로 구성되어 있다고 가정 
  * 클러스터는 각 키를 해시 처리하고, 해시 값에 따라 키를 A 또는 B 샤드에 할당 
  * 특정 키 key1, key2, key3이 각각 A, B, A 샤드에 할당된 상태 

**Redis 클러스터에서 잘못된 노드로 요청했을 때 (MOVED 리다이렉트)**
* Redis 클러스터에서 클라이언트가 키를 요청할 때, 해당 키가 없는 노드에 요청을 보내면 해당 노드는 MOVED 리다이렉트 응답을 반환.
  * `MOVED 7000 192.168.1.2:6379`
    * 7000 → 키가 속한 해시 슬롯 번호 
    * 192.168.1.2:6379 → 해당 슬롯을 담당하는 올바른 노드
  * 클라이언트는 MOVED 응답을 받은 후, 응답에 포함된 올바른 노드로 직접 요청을 다시 보냄
  * Redis 클러스터를 지원하는 클라이언트(Jedis, Lettuce, Redisson 등)는 자동으로 처리

**문제 발생**
* 노드를 하나 더 추가해 3개의 샤드 노드(A, B, C)로 확장하는 경우, 해시 방식으로는 전체 데이터를 다시 해시 계산하여 새로 할당해야 한다.
* 결과적으로, 기존 키의 저장 위치가 대부분 변경되어 A와 B 샤드의 많은 키가 C로 재배치되어야 하며, 이는 큰 리소스를 소모하게 된다.

**해시 슬롯을 도입한 해결 예시**
* Redis는 해시 슬롯을 총 16,384개로 나누고, 각 노드에 슬롯을 분배 
* 노드 A: 0 ~ 8191 슬롯 
* 노드 B: 8192 ~ 16383 슬롯 
* 각 키를 해시하여 얻은 해시 값을 16,384로 나눈 나머지 값으로 해시 슬롯을 결정한다. 
  * key1이 1024 슬롯에 속하면 A에 할당
  * key2가 12288 슬롯에 속하면 B에 할당
  * 노드 C를 추가하는 경우, 전체 키를 재정립하지 않고, 슬롯 5461 ~ 10922에만 C에 할당하도록 설정
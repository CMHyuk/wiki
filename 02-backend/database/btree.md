## B tree 계열을 DB 인덱스로 사용하는 이유

BST = 자녀 노드는 최대 두 개까지 허용  
자녀 노드를 3개 이상 가지게 하려면?  
→ ? < 50 , 50 < ? < 80 , ? > 80 의 형태가 되려면 부모 노드는 50 80 두 개가 있어야함

#### B tree
- 자녀 노드의 최대 개수를 늘리기 위해서 부모 노드에 key를 하나 이상 저장한다
- 부모 노드의 key들을 오름차순으로 정렬
- 정렬된 순서에 따라 자녀 노드들의 key 값의 범위가 결정
→ 자녀 노드의 최대 개수를 입맛에 맞게 결쟁해서 쓸 수 있음

```
M : 각 노드의 최대 자녀 노드 수
M - 1 : 각 노드의 최대 key 수
M/2 (올림) : 각 노드의 최소 자녀 노드 수
M/2 : 최소 key 수
```

데이터 추가는 항상 leaf 노드에 함   
노드가 넘치면 가운데 key를 기준으로 좌우 key들을 분할하고 가운데 key는 승진  
모든 leaf 노드들은 같은 레벨에 있음

cpu - 프로그램 코드가 실제로 실행되는 곳
Main memory (ram) - 실행 중인 프로그램의 코드들과 코드 실행에 필요한 혹은 그 결과로 나온 데이터들이 상주하는 곳
Secondary storage (ssd, hdd) - 프로그램과 데이터가 영구적으로 저장되는 곳, 실행 중인 프로그램의 데이터 일부가 임시 저장되는 곳

Secondary storage
- DB가 저장되는 곳
- 데이터를 처리하는 속도가 가장 느림
- 데이터를 저장하는 용량이 가장 큼
- block 단위로 데이터를 읽고 씀
    - block - file system이 데이터를 읽고 쓰는 논리적인 단위
    - 불필요한 데이터까지 읽어올 가능성이 있음
        - DB에서 데이터를 조회할 때 최대한 적게 접근하는 것이 성능면에서 좋음
        - 연관된 데이터를 모아서 저장하면 더 효율적으로 읽고 쓸 수 있음

#### B tree 계열을 DB 인덱스로 사용하는 이유
- BST에 비해 접근을 적게 함
- B tree 노드는 block 단위의 저장 공간을 알차게 사용 가능

#### hash index를 쓰는 건?
* 삽입/삭제/조회의 시간 복잡도가 O(1)이지만, equality(=) 조회만 가능하고 범위 기반 검색이나 정렬에는 사용 불가

**복합 인덱스**는 같음, 정렬, 다중 값, 카디널리티 순이고, 생성 순서에 따라 인덱스 성능이 달라진다

1. ==, equal 쿼리가 있으면 제일 먼저 인덱스로 설정 ex) where id=1 이면 id에 인덱스 설정
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 <등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
4. 유니크한 값의 정도를 카디널리티, 높은 순서를 기반으로 인덱스를 생성 age, email 중 email이 높기 때문에 email이라는 필드에 대한 인덱스를 먼저 생성해야 함

출처 - 쉬운코드 유튜브 채널
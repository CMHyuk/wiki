## 애플리케이션 서버

- 하드웨어에서 실행 중인 소프트웨어
  - "서버의 전원이 꺼졌습니다" -> 하드웨어 서버
  - "서버 설치 파일을 다운받았습니다" -> 소프트웨어 서버

---

## 서버 운영 방식

### 베어메탈 (Bare Metal)

- **구조**  
  - 물리 서버(Hardware) → 운영체제(OS) → 애플리케이션
- **방식**  
  - 가상화 기술을 사용하지 않고, 하나의 OS 위에서 여러 애플리케이션을 직접 실행.
- **특징**
    - 가상화 계층이 없어서 성능 손실 없음 (최대 성능 보장)
    - 하지만 **격리 불가능** → 어떤 한 프로그램이 에러나면 다른 프로그램에도 영향
    - 서버 자원 활용이 비효율적일 수 있음 (한 서버 = 한 OS)
- **예시**: 물리 서버에 리눅스/윈도우를 설치 후 직접 서비스 실행

### 가상화 (Virtualization)

- **구조**  
  - 물리 서버(Hardware) → 하이퍼바이저(Hypervisor) → 게스트 OS(Guest OS) → 애플리케이션
- **방식**  
  - 하이퍼바이저가 물리 자원을 분할해서 **가상 머신(가상 서버)** 단위로 운영체제를 여러 개 띄움.
- **특징**
    - 각 VM마다 **완전한 운영체제** 필요 → 무겁고 부팅/자원 소모 큼
    - 보안과 격리 강력 (VM 간 간섭 거의 없음)
    - 어떤 한 VM(프로그램)이 에러가 나도 다른 VM에는 영향 없음
    - 기존 애플리케이션(레거시 포함) 그대로 옮겨서 실행하기 좋음
- **예시**: VMware ESXi, KVM, Hyper-V

### 컨테이너 (Container)

- **구조**  
  - 물리 서버(Hardware) → 호스트 OS → 컨테이너 런타임(Docker, containerd 등) → 컨테이너(애플리케이션 + 라이브러리)
- **방식**
  - 호스트 OS의 커널을 공유하면서 프로세스를 격리 (Linux Namespace, Cgroups).
- **특징**
    - 운영체제를 따로 설치하지 않고, 애플리케이션 실행에 필요한 **라이브러리/환경만 패키징**
    - 가볍고 빠름 (VM보다 자원 효율성 높음)
    - 이식성 뛰어남 (개발-PC, 테스트, 클라우드 어디서든 동일하게 실행)
    - 보안은 VM보다 약할 수 있음 (커널 공유)
    - 어떤 한 컨테이너가 죽어도 다른 컨테이너는 대부분 영향 없음
- **예시**: Docker, Kubernetes (오케스트레이션 도구)

---

## 차이 요약

| 구분     | 베어메탈 (Bare Metal)   | 가상화 (VM)             | 컨테이너                           |
|--------|---------------------|----------------------|--------------------------------|
| 격리 단위  | 없음 (OS + 애플리케이션 공유) | **운영체제(OS) 단위**      | **프로세스 단위**                    |
| 필요 요소  | 단일 OS               | VM마다 게스트 OS 필요       | 호스트 OS 공유, 앱 실행 환경만 포함         |
| 성능     | 최고 성능 (오버헤드 없음)     | 무겁고 오버헤드 큼           | 가볍고 빠름                         |
| 안정성/격리 | 한 앱 에러 → 전체 영향      | VM 간 완전 격리, 안전       | 컨테이너 간 격리 (커널 공유로 보안은 상대적 약함)  |
| 대표 기술  | 리눅스/윈도우 직접 실행       | VMware, Hyper-V, KVM | Docker, containerd, Kubernetes |

---

## 도커
- 컨테이너 엔진과 컨테이너 런타임으로 구성

### 컨테이너 엔진
- 사용자의 요청을 받아 컨테이너를 관리해주는 역할

### 컨테이너 런타임
- 직접 커널과 통신하면서 격리된 공간을 만드는 역할 
- 도커는 RUNC라는 컨테이너 런타임을 사용
- 도커는 클라이언트 - 서버 모델로 실행 (CLI, 도커 데몬)

### 요청 흐름

1. 명령어 실행
2. 사용자 명령을 API에 맞추어 변환
3. 데몬에 API 요청
    - 도커 데몬에게 전달 (컨테이너를 관리하는 기능 제공 = 도커 D라고도 부름)
    - 일반적으로 데몬은 서버에서 지속적으로 실행되는 소프트웨어를 말함
    - 컨테이너의 생성, 실행, 관리 등을 담당하며, 도커 클라이언트의 요청을 받아들이고 처리
4. 컨테이너 관리
5. 결과 전달
6. 결과 표시

### 컨테이너 실행

- `docker version` - client, server의 버전 및 상태 확인
- `docker info` - 플러그인, 시스템 상세 정보 확인
- `docker --help` - 메뉴얼 확인
- `docker (Mangement Command) Command` - 대분류 소분류, Management는 대부분 생략 가능
  - ex) docker (container) run
- `docker run (실행옵션) 이미지명` - 컨테이너 실행 
  - 실행옵션 - 컨테이너 이름이나 포트 설정 가능  
  - ex) docker run -p 80:80 --name hellonginx nginx
- `docker rm 컨테이너명/ID` - 컨테이너 삭제
  - ex) docker rm hellonginx
- 명령어를 CLI가 API 맞게 변환 -> 도커 데몬에게 전달 -> 컨테이너 런타임을 통해 컨테이너 실행
## B tree 계열을 DB 인덱스로 사용하는 이유

BST = 자녀 노드는 최대 두 개까지 허용  
자녀 노드를 3개 이상 가지게 하려면?  
→ ? < 50 , 50 < ? < 80 , ? > 80 의 형태가 되려면 부모 노드는 50 80 두 개가 있어야함

#### B tree
- 자녀 노드의 최대 개수를 늘리기 위해서 부모 노드에 key를 하나 이상 저장한다
- 부모 노드의 key들을 오름차순으로 정렬
- 정렬된 순서에 따라 자녀 노드들의 key 값의 범위가 결정
→ 자녀 노드의 최대 개수를 입맛에 맞게 결쟁해서 쓸 수 있음

```
M : 각 노드의 최대 자녀 노드 수
M - 1 : 각 노드의 최대 key 수
M/2 (올림) : 각 노드의 최소 자녀 노드 수
M/2 : 최소 key 수
```

데이터 추가는 항상 leaf 노드에 함   
노드가 넘치면 가운데 key를 기준으로 좌우 key들을 분할하고 가운데 key는 승진  
모든 leaf 노드들은 같은 레벨에 있음

cpu - 프로그램 코드가 실제로 실행되는 곳
Main memory (ram) - 실행 중인 프로그램의 코드들과 코드 실행에 필요한 혹은 그 결과로 나온 데이터들이 상주하는 곳
Secondary storage (ssd, hdd) - 프로그램과 데이터가 영구적으로 저장되는 곳, 실행 중인 프로그램의 데이터 일부가 임시 저장되는 곳

Secondary storage
- DB가 저장되는 곳
- 데이터를 처리하는 속도가 가장 느림
- 데이터를 저장하는 용량이 가장 큼
- block 단위로 데이터를 읽고 씀
    - block - file system이 데이터를 읽고 쓰는 논리적인 단위
    - 불필요한 데이터까지 읽어올 가능성이 있음
        - DB에서 데이터를 조회할 때 최대한 적게 접근하는 것이 성능면에서 좋음
        - 연관된 데이터를 모아서 저장하면 더 효율적으로 읽고 쓸 수 있음

#### B tree 계열을 DB 인덱스로 사용하는 이유
- BST에 비해 접근을 적게 함
- B tree 노드는 block 단위의 저장 공간을 알차게 사용 가능

#### hash index를 쓰는 건?
* 삽입/삭제/조회의 시간 복잡도가 O(1)이지만, equality(=) 조회만 가능하고 범위 기반 검색이나 정렬에는 사용 불가  

출처 - 쉬운코드 유튜브 채널
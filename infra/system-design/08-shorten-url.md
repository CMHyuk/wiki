### URL 단축키 설계

**요구사항**
* 쓰기 연산: 매일 1억 개의 단축 URL 생성
* 초당 쓰기 연산: 1억/24/3600 = 1160
* 읽기 연산: 읽기 연산과 쓰기 연산 비율은 10:1이라고 하자. 그 경우 읽기 연산은 초당 11,600회 발생한다.
* URL 단축 서비스를 10년간 운영한다고 가정하면 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 한다.
* 축약 전 URL의 평균 길이는 100이라고 하자.
* 따라서 10년 동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5TB이다.

**API 엔드 포인트**
* URL 단축키는 기본적으로 두 개의 엔드포인트를 필요로 한다.
  * URL 단축용 엔드포인트: 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 한다.
    * `POST /api/v1/data/shorten`
      * 인자: {longUrl:longURLstring}
      * 반환: 단축 URL
  * URL 리디렉션용 엔드포인트: 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트
    * `GET /api/v1/shortUrl`
      * 반환: HTTP 리디렉션 목적지가 될 원래 URL

**URL 리디렉션**
* 브라우저에 단축 URL을 입력하면 단축 URL을 받은 서버는 그 URL을 원래 URL로 바꿔서 301 응답의 Location 헤더에 넣어 반환한다.
  * 301 Permanently Moved: 이 응답은 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적으로 이전되었으므로, 브라우저는 이 응답을 캐시한다.
  * 302 Found: 이 응답은 주어진 URL로의 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다. 따라서 클라이언트의 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 되어야 한다.
* 서버 부하를 줄이는 것이 중요하다면 301이 좋지만 트래픽 분석이 중요할 때는 302를 쓰는 쪽이 클릭 발생률이나 발생 위치를 추적하는 데 좀 더 유리하다.
* URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것이다. 해시 테이블에 <단축 URL, 원래 URL>의 쌍을 저장한다.
  * 원래 URL = hashTable.get(단축 URL)
  * 301 또는 302 응답 Location 헤더에 원래 URL을 넣은 후 전송
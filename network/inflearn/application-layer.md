## 응용 계층

**전체 주소 도메인 네임 (FQDN; Fully-Qualified Domain Name)**

- 전체 도메인 계층을 모두 포함하는 도메인 네임
- FQDN까지 알면 비로소 하나의 호스트를 식별할 수 있게 됨

**도메인 네임에 대응하는 IP 주소를 알아내는 과정**

- 계층적이고 분산된 네임 서버들이 사용됨
- 주요 네임 서버 유형: 로컬 네임 서버, 루트 네임 서버, TLD(최상위 도메인) 네임 서버, 책임 네임 서버

**로컬 네임 서버**

- 클라이언트와 맞닿아 있는 네임 서버
- 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
- 로컬 네임 서버의 주소는 일반적으로 ISP에서 할당
- 공개 DNS 서버를 이용할 수도 있음
    - 구글의 8.8.8.8, 8.8.4.4

**TLD 네임 서버**

- TLD를 관리하는 네임 서버
- DNS 질의에 대해 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소 반환
    - 하위 도메인 네임을 관리하는 네임 서버는 그보다 하위 도메인 네임을 관리하는 네임 서버 주소를 반환
        - 로컬 네임 서버가 www.example.com의 IP 주소를 TLD 네임 서버에 물어보는 경우 TLD 네임 서버는 example.com을 관리하는 네임 서버의 주소를 알려줌

**책임 네임 서버**

- 특정 도메인 영역을 관리하는 네임 서버
    - 다른 네임 서버에게 떠넘기지 않고 곧바로 답할 수 있는 네임 서버
    - 즉, 책임 네임 서버는 로컬 네임 서버가 마지막으로 질의하는 네임 서버
    - 일반적으로 로컬 네임 서버는 책임 네임 서버로부터 원하는 IP 주소를 얻어냄

**재귀적 질의**

- 클라이언트 -> 로컬 네임 서버 -> 루트 네임 서버 -> TLD 네임 서버 -> 책임 네임 서버에게 질의
- 최종 응답 결과를 역순으로 전달

**반복적 질의**

- 네임 서버에 일일이 질의-응답 반복
- 최종 응답 결과를 클라이언트에게 전달

**DNS 캐시**

- 재귀적, 반복적 질의는 시간이 오래 걸리고 네트워크상의 메시지 수가 지나치게 늘어날 수 있고, 루트 네임 서버에 과부하 우려
- 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용
- DNS 캐시를 저장하는 용도로만 사용되는 서버도 있음
- DNS 캐시를 활용하면 더 짧은 시간 안에 원하는 IP 주소를 얻어낼 수 있음
- DNS 캐시는 TTL 값과 함께 저장하기 때문에 영원히 남아있는 것은 아님

### DNS 레코드 유형

| 레코드 유형 | 설명                                       | 예시                                    |
|--------|------------------------------------------|---------------------------------------|
| A      | 도메인 이름을 **IPv4 주소**에 매핑                  | example.com → 93.184.216.34           |
| AAAA   | 도메인 이름을 **IPv6 주소**에 매핑                  | example.com → 2606:2800:220:1:248:... |
| CNAME  | 도메인 별칭(Alias)을 **다른 도메인 이름**에 매핑         | www.example.com → example.com         |
| NS     | 해당 도메인의 **네임서버**를 지정                     | example.com → ns1.provider.com        |
| MX     | 이메일 수신을 위한 **메일 서버**를 지정                 | example.com → mail.example.com        |
| TXT    | 도메인에 대한 **텍스트 정보** 제공 (SPF, 도메인 소유 증명 등) | "v=spf1 include:_spf.google.com ~all" |

---

### HTTP

**HTTP의 네 가지 특성**

- 요청-응답 기반 프로토콜
    - HTTP는 클라이언트-서버 구조 기반의 요청-응답 프로토콜
    - HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름
- 미디어 독립적 프로토콜
    - 미디어 타입: HTTP에서 메시지로 주고받는 자원의 종류, 웹 세상의 확장자
        - MIME 타입이라고도 함
    - 즉, HTTP는 주고받을 미디어 타입에 특별히 제한을 두지 않고 동작하는 미디어 독립적 프로토콜
- Stateless 프로토콜
    - HTTP는 상태를 유지하지 않는 stateless 프로토콜
    - 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미
    - 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주
    - 상태를 유지하지 않는 이유
        - HTTP 서버는 일반적으로 많은 클라이언트와 동시에 상호 작용
        - 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담
        - 특정 클라이언트가 특정 서버에 종속되지 않게 함
        - 서버에 문제가 생겨도 다른 서버로 대체 용이
- 지속 연결 프로토콜
    - 비지속 연결
        - 초기의 HTTP 버전(HTTP 1.0 이하)
        - TCP 연결 수립한 후, 요청에 대한 응답을 받으면 연결 종료
        - 추가적인 요청-응답을 하기 위해서는 다시 TCP 연결 수립부터 반복
    - 지속 연결 또는 킵 얼라이브
        - 최근 대중적으로 사용되는 HTTP 버전(HTTP 1.1 이상)
        - 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술

**HTTP의 발전**

| 버전           | 출시 연도 | 주요 특징                                            | 연결 방식              | 성능 개선 사항                             | 단점 / 한계                                  |
|--------------|-------|--------------------------------------------------|--------------------|--------------------------------------|------------------------------------------|
| **HTTP/1.0** | 1996  | - 최초의 정식 HTTP<br>- 요청마다 TCP 연결                   | 짧은 연결 (비지속)        | 없음                                   | - 매 요청마다 TCP 재연결 필요<br>- 헤더 전송 비효율적      |
| **HTTP/1.1** | 1997  | - 기본 버전으로 현재도 많이 사용<br>- `Keep-Alive`로 연결 재사용 가능 | 지속 연결 (Persistent) | - 파이프라이닝 (실험적)<br>- 캐싱, 호스트 헤더 도입    | - 요청 순서 블로킹 (HOL blocking)<br>- 동시 요청 병목 |
| **HTTP/2**   | 2015  | - 바이너리 기반<br>- 다중 요청 병렬 처리 (Multiplexing) 지원     | 하나의 TCP 연결         | - 헤더 압축 (HPACK)<br>- 서버 푸시           | - 여전히 TCP 기반 → 패킷 손실 시 모든 스트림 지연 가능성     |
| **HTTP/3**   | 2022  | - **QUIC 프로토콜** 기반 (UDP 위에서 작동)<br>- 완전한 멀티플렉싱   | UDP 기반 QUIC        | - 연결 지연 감소 (0-RTT 지원)<br>- 손실 영향 최소화 | - 네트워크 및 장비 호환성 이슈<br>- 구현 난이도 상대적으로 높음  |



### **HTTP(HyperText Transfer Protocol)**

**인터넷에서 데이터를 주고받을 수 있는 프로토콜**

HTTP 메시지에 모든 것을 전송

HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML (API)

### **특징**

### **클라이언트 서버 구조**

클라이언트는 서버에 요청을 보내고, 응답을 대기

서버가 요청에 대한 결과를 만들어서 응답

### **무상태 프로토콜**

- **상태 유지** : 중간에 서버가 장애나면 처음부터 다시 요청해야함
- **무상태** : 서버가 클라이언트의 상태를 보존 x


  장점 : 서버 확장성 높음 (스케울 아웃)

  무상태는 응답 서버를 쉽게 바꿀 수 있음 -> 무한한 서버 증설 가능 (서버가 상태를 보관하지 않음)

  중간에 서버가 장애나도 다른 서버에 요청하면 됨


  단점 : 클라이언트에서 전송되는 데이터가 많음


### **비연결성**

**연결을 유지하는 모델**

* 서버는 연결을 계속 유지, 서버 자원 소모

**연결을 유지하는 않는 모델**

* 데이터 주고 받고 연결 끊음

* 서버는 연결 유지 x, 최소한의 자원 유지

* HTTP는 기본이 연결을 유지하지 않는 모델

* 일반적으로 초 단위의 이하의 빠른 속도로 응답

* 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음

    * 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다

* 서버 자원을 매우 효율적으로 사용할 수 있음

**단점**

* TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가

* 웹 브라우저로 사이트를 요청하면 html, javascript, css, 추가 이미지 등 수 많은 자원이 함께 다운로드
    * 지금은 HTTP 지속 연결로 문제 해결

**HTTP 초기: TCP/IP 연결 후 html 요청, 응답 받고 끊고 다시 연결하고 자바스크립트 요청, 응답받고 끊고 ...**

**지속 연결 : TCP/IP 연결 후 모든 파일 요청, 응답 받고 종료로 시간 단축**

### **HTTP 메시지**

**시작 라인**

요청 : HTTP 메서드, 요청 대상, HTTP Version

응답 : HTTP 버전, HTTP 상태 코드, 이유 문구

**헤더 : HTTP 전송에 필요한 모든 부가 정보**

ex) 메시지 바디의 내용, 크기, 압축, 인증 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보..

메시지 바디의 내용을 제외한 모든 정보가 들어갔다고 생각

**공백 라인 (무조건 있어야함)**

**메시지 바디(올 수도 있고 안 올수도 있음)**

실제 전송할 데이터

HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

### **단순함, 확장 가능**

### **HTTP 메서드**

GET : 리소스 조회

POST : 요청 데이터 처리, 주로 등록에 사용

PUT : 리소스를 대체, 해당 리소스가 없으면 생성

PATCH : 리소스 부분 변경

DELETE : 리소스 삭제

**GET**

* 리소스 조회

* 서버에 전달하고 싶은 데이터는 쿼리 파라미터를 통해서 전달

* 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음

**POST**

* 요청 데이터 처리

* 메시지 바디를 통해 서버로 요청 데이터 전달

* 서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행

* 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
    * 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순한 값 변경을 넘어 프로세스의 상태가 변경되는 경우
  
* 새 리소스 생성

* 다른 메서드로 처리하기 애매한 경우
    * JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우

**PUT**

리소스가 있으면 대체 없으면 생성

쉽게 이야기해서 덮어버림

클라이언트가 리소스 위치를 알고 있음 (POST와 차이점)

**PATCH**

리소스 부분 변경

**DELETE**

리소스 제거

**Safe**

호출해도 리소스를 변경하지 않는다

**멱등**

한 번 호출 = 100번 호출

GET : 한 번 조회하든, 두 번 조회하든 같은 결과

PUT : 결과를 대체, 따라서 같은 요청을 여러번 해도 최종 결과는 같음

DELETE : 결과를 삭제, 같은 요청을 여러번 해도 삭제된 결과는 같음

POST : 멱등이 아님, 두 번 호출하면 같은 결제가 중복해서 발생

PATCH : 멱등이 아님 만약 count++ 할 경우 계속 결과가 다름

#### 활용

* 자동 복구 메커니즘

* 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 판단 근거

멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지 고려 x

동일한 사용자가 똑같은 요청한 것만 고려

**캐시가능**

* 응답 결과 리소스를 캐시해서 사용해도 되는가?
    * GET, HEAD, POST, PATCH 캐시 가능 
    * 실제로는 GET, HEAD 정도만 캐시로 사용 
    * 나머지는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음